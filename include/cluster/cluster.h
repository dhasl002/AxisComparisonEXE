#ifndef ULTILITY_H
#define ULTILITY_H
#include <iostream>
#include <fstream>
#include <string>
#include <sstream>
#include <vector>
#include <cstdlib>
#include <cmath>
#include <cstring>
//#include "Ultility.h"
//#include "Vectors.h"
//#include "SequenceNode.h"
//#include "StickNode.h"
//#include "dirFile.h"
//#include "Point.h"
#include "geometry.h"

using namespace std;

void getTrace(const vector<pair<int, int> > &);
void extendLine(Coordinate, Coordinate, Coordinate &, Coordinate &, double);//extend line to specific length
void saveClusterCenter(vector<vector<Coordinate> >, string);//save cluster centers to a file
void savePoint(vector<Coordinate>, string);//save points to a file
bool withinRange(Coordinate, Coordinate, double);//check if two points are in the range
int getCentralPoint(const vector<Coordinate> &, const Coordinate &, const vector<bool> &);//get the index of the closest point to current point
bool isAllMarked(vector<bool>);//check if all marks have been set
void clusterRecursion(const vector<Coordinate> &, vector<vector<Coordinate> > &, vector<bool> &, Coordinate, double);//recursion function to cluster points
Coordinate getClusterCenter(const vector<Coordinate> &);//get the central point of the cluster
void peakClustering(const vector<Coordinate> &, vector<vector<Coordinate> > &, Coordinate, double);//cluster points and output the central points of clusters into ./other/cluster.pdb
double linePointIntersection(Coordinate, Coordinate, Coordinate, Coordinate &);
double round(double, int);
void showSequence(const vector<SequenceNode> &container);
void readSequence(vector<SequenceNode> &container, string name);
void showSticks(const vector<StickNode> &container);
void readSticks(vector<StickNode> &container, string name, string type);

//get all the trace between SSEs by the topology
//all the points and traces are read from the files which are generated by Kamal's code
void getTrace(const vector<pair<int, int> > &topology)
{
	//create folder to save the trace points and stick points
	DFCDirectory("./other/Coordinate");

	//read all clique central point from cliqueCenter.txt
	vector<Coordinate> pointContainer;

	ifstream cliqueCenterFile("./input/cliqueCenter.txt");

	if(!cliqueCenterFile)
	{
		cerr<<"Can not open ./input/cliqueCenter.txt ..."<<endl;
		exit(1);
	}

	string str;

	while(getline(cliqueCenterFile, str))
	{
		stringstream stream;
		stream<<str;
		double xTemp, yTemp, zTemp;
		stream>>xTemp>>yTemp>>zTemp;
		Coordinate pointTemp(xTemp, yTemp, zTemp);
		pointContainer.push_back(pointTemp);
	}

	cliqueCenterFile.close();

	//save clique cenral point
	ofstream cliqueFile("./other/Coordinate/clique.pdb");
	for(int i = 0; i < pointContainer.size(); i++)
		pointContainer[i].save(cliqueFile);
	cliqueFile.close();

	//get the trace points
	vector<vector<Coordinate> > traceContainer;
	ifstream tracePathFile("./input/tracePath.txt");

	if(!tracePathFile)
	{
		cerr<<"Can not open tracePath.txt"<<endl;
		exit(1);
	}

	while(getline(tracePathFile, str))
	{
		vector<Coordinate> traceTemp;
		char *strTemp;
		strTemp = new char [str.size()+1];
		strcpy(strTemp, str.c_str());

		char *pch;
		pch = strtok(strTemp, " ");

		while(pch != NULL)
		{
			traceTemp.push_back(pointContainer[atoi(pch)]);
			pch = strtok(NULL, " ");
		}

		traceContainer.push_back(traceTemp);
	}

	tracePathFile.close();

	//save each trace points
	for(int i = 0; i < traceContainer.size(); i++)
	{
		stringstream stream;
		stream<<"./other/Coordinate/trace"<<i<<".pdb";
		ofstream traceTempFile(stream.str().c_str());
		for(int j = 0; j < traceContainer[i].size(); j++)
		{
			traceContainer[i][j].save(traceTempFile, j);
		}
		traceTempFile.close();
	}

	vector<vector<Coordinate> > topologyTraceContainer;
	ifstream weightListFile("./input/weightList.txt");

	if(!weightListFile)
	{
		cerr<<"Can not open weightList.txt"<<endl;
		exit(1);
	}

	while(getline(weightListFile, str))
	{
		stringstream stream;
		stream<<str;

		int startFirst, startSecond, endFirst, endSecond, startTrace, endTrace;
		double weight;
		stream>>startFirst>>startSecond>>endFirst>>endSecond>>weight>>startTrace>>endTrace;
		for(int i = 0; i < topology.size()-1; i++)
		{
		}
	}
}

//extend line by the length expected
void extendLine(Coordinate a, Coordinate b, Coordinate &aTemp, Coordinate &bTemp, double l)
{
	double ratio;
	ratio = l/a.dist(b);

	Coordinate c;
	c.set((a.getX()+b.getX())/2, (a.getY()+b.getY())/2, (a.getZ()+b.getZ())/2);

	bTemp.set(c.getX()+(b.getX()-c.getX())*ratio, c.getY()+(b.getY()-c.getY())*ratio, c.getZ()+(b.getZ()-c.getZ())*ratio);

	aTemp.set(c.getX()+(a.getX()-c.getX())*ratio, c.getY()+(a.getY()-c.getY())*ratio, c.getZ()+(a.getZ()-c.getZ())*ratio);
}

//save cluster centers to a specific file
void saveClusterCenter(vector<vector<Coordinate> > cluster, string str)
{
	vector<Coordinate> centerPointContainer;

	for(int i = 0; i < cluster.size(); i++)
	{
		Coordinate center;
		center = getClusterCenter(cluster[i]);
		centerPointContainer.push_back(center);
	}

	savePoint(centerPointContainer, str);
}

//save points to a specific file
void savePoint(vector<Coordinate> points, string str)
{
	ofstream file(str.c_str());

	for(int i = 0; i < points.size(); i++)
	{
		points[i].save(file, 0, 0);
	}

	file.close();
}

//check if two points are in the specific range
bool withinRange(Coordinate a, Coordinate b, double r)
{
	double temp;
	temp = a.dist(b);
	//roundValue(temp);
	temp = round(temp, 3);

	if(temp <= r)
		return true;

	return false;
}

//get closest point to current point that has not been marked
int getCentralPoint(const vector<Coordinate> &pointContainer, const Coordinate &prevCentralPoint, const vector<bool> &mark)
{
	double minDist = 999;
	int minIndex = -1;

	for(int i = 0; i < pointContainer.size(); i++)
	{
		if(mark[i])//only check the points that are marked
		  continue;

		double tempDist;
		tempDist = prevCentralPoint.dist(pointContainer[i]);

		//roundValue(tempDist);
		tempDist = round(tempDist, 3);

		if(tempDist < minDist)
		{
			minDist = tempDist;
			minIndex = i;
		}
	}

	return minIndex;
}

//check if all mark has been set to be true
bool isAllMarked(vector<bool> container)
{
	for(int i = 0; i < container.size(); i++)
		if(!container[i])
			return false;

	return true;
}

//recursion function to cluster points
void clusterRecursion(const vector<Coordinate> &pointContainer, vector<vector<Coordinate> > &clusterContainer, vector<bool> &mark, Coordinate prevCentralPoint, double r)
{
	//return if all points are clustered
	if(isAllMarked(mark))
		return;

	//get central point
	Coordinate centralPoint;
	int tempIndex;

	tempIndex = getCentralPoint(pointContainer, prevCentralPoint, mark);//get the closest point to previous central point as new central point

	centralPoint = pointContainer[tempIndex];
	mark[tempIndex] = true;

	//create new cluster
	vector<Coordinate> cluster;

	cluster.push_back(centralPoint);//push central point to cluster

	//create cluster
	int i;
	for(i = 0; i < pointContainer.size(); i++)
	{
		//push valid point to cluster
		if(withinRange(centralPoint, pointContainer[i], r) && !mark[i])//within range and unmarked
		{
			//set new central point
			double tempx, tempy, tempz;

			tempx = (centralPoint.getX()*cluster.size()+pointContainer[i].getX())/(cluster.size()+1);
			tempy = (centralPoint.getY()*cluster.size()+pointContainer[i].getY())/(cluster.size()+1);
			tempz = (centralPoint.getZ()*cluster.size()+pointContainer[i].getZ())/(cluster.size()+1);

			//push point to cluster
			cluster.push_back(pointContainer[i]);
			mark[i] = true;//set mark to true for this point

			//reset central point
			Coordinate centralPointTemp;
			centralPointTemp.set(tempx, tempy, tempz);

			centralPoint = centralPointTemp;

			i = 0;
		}
	}

	clusterContainer.push_back(cluster);

	clusterRecursion(pointContainer, clusterContainer, mark, centralPoint, r);
}

//get the center of cluster
Coordinate getClusterCenter(const vector<Coordinate> &cluster)
{
	Coordinate temp;

	for(int i = 0; i < cluster.size(); i++)
	{
		temp.set(cluster[i].getX()+temp.getX(), cluster[i].getY()+temp.getY(), cluster[i].getZ()+temp.getZ());
	}

	temp.set(temp.getX()/cluster.size(), temp.getY()/cluster.size(), temp.getZ()/cluster.size());

	return temp;
}

//cluster points by cutoff r
void peakClustering(const vector<Coordinate> &pointContainer, vector<vector<Coordinate> > &clusterContainer, Coordinate startPoint, double r)
{
	vector<bool> mark;
	for(int i = 0; i < pointContainer.size(); i++)
		mark.push_back(false);

	clusterRecursion(pointContainer, clusterContainer, mark, startPoint, r);

	cout<<"\n================================="<<endl;
	cout<<"Have done clustering of voxel ..."<<endl;
	cout<<"All voxels are clustered to "<<clusterContainer.size()<<" clusters ..."<<endl;
	//for(int i = 0; i < clusterContainer.size(); i++)
		//cout<<i<<" "<<clusterContainer[i].size()<<endl;

	cout<<"Output clusters centers to ./other/clusterCenter.pdb ..."<<endl;
	saveClusterCenter(clusterContainer, "./other/clusterCenter.pdb");
	cout<<"==================================="<<endl;
	/*ofstream centerFile("./other/center.pdb");//save the center points of cluster
	vector<Coordinate> clusterCenterPoints;
	for(int i = 0; i < clusterContainer.size(); i++)
	{
		getClusterCenter(clusterContainer[i]).save(centerFile, 0, 0);
	}
	centerFile.close();*/

	/*for(int i = 0; i < clusterContainer.size(); i++)
	{
		stringstream stream;
		stream<<"./other/Cluster"<<i<<".pdb";
		savePoint(clusterContainer[i], stream.str());
	}*/
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//given a line and a point, returns the point where these two intersect
//it looks faster than the other one "Coordinate pointLineIntersection(Coordinate p1,Coordinate p2,Coordinate p3)"
double linePointIntersection(Coordinate lineP1, Coordinate lineP2, Coordinate p, Coordinate &intersectionPnt){

	//create the vectors represents the line and a nother vector represents a line from lineP1 and the point p
	Vectors v1(lineP2, lineP1), v2(p,lineP1);

	double dotProd = v1.dot(v2);
	double lineLengthSqr = (lineP2.getX() - lineP1.getX())*(lineP2.getX() - lineP1.getX()) + (lineP2.getY() - lineP1.getY())*(lineP2.getY() - lineP1.getY()) + (lineP2.getZ() - lineP1.getZ())*(lineP2.getZ() - lineP1.getZ());

	double e = dotProd/lineLengthSqr;


	intersectionPnt.set(lineP1.getX() + e * (lineP2.getX() - lineP1.getX()), lineP1.getY() + e * (lineP2.getY() - lineP1.getY()), lineP1.getZ() + e * (lineP2.getZ() - lineP1.getZ()));

	/*
	if e is :
		negative	: the intersection point is before point#1 in the line
		0			: the intersection point is on the first point
		b/w (0,1)	: the intersection point is on the line
		> 1			: the intersection point is after the second point in the line
	*/
	return e;
}

//round a double number, precision number is greater than 0
double round(double num, int precision)
{
	double temp;

	double pow10;

	pow10 = pow(10, precision-1);

	temp = fabs(num)*pow10;

	temp = double(int(temp+0.5))/pow10;

	if(num > 0)
		return temp;
	else
		return temp*(-1);
}

void showSticks(const vector<StickNode> &container)
{
	cout<<"\n=========Sticks========"<<endl;
	for(int i = 0; i < container.size(); i++)
		container[i].show();
	cout<<"========================\n"<<endl;
}

void readSticks(vector<StickNode> &container, string name, string type)
{
	if(name.substr(0, 1) == "-")
	{
		cerr<<"No "<<type<<" information will be read ..."<<endl;
		return;
	}

	ifstream file;
	/*file.open(name.c_str());

	if(!file)
	{
		cerr<<"Can not open "<<name<<endl;
		exit(1);
	}*/

	file.exceptions(ifstream::badbit);

	try{
		file.open(name.c_str());
	}
	catch(ifstream::failure e)
	{
		cerr<<__FILE__<<"/"<<__LINE__<<"Can not open "<<name<<", "<<e.what()<<endl;
		exit(1);
	}

	string str;

	int index = 0;
	bool finish = false;

	//read sticks
	while(!file.eof())
	{
		vector<Coordinate> pointContainer;//save points in each stick
		//read single stick
		while(getline(file, str) && str.size() > 5)
		{
			//stop when meet "----------------", which is comment line, content after this line is used to save true topology information
			if(str.substr(0, 1) == "-")
			{
				finish = true;
				break;
			}

			if(str.size() > 10)
			{
				stringstream stream;
				stream<<str;
				double x, y, z;
				stream>>x>>y>>z;
				Coordinate pointTemp(x, y, z);
				pointContainer.push_back(pointTemp);
			}
		}

		if(pointContainer.size() > 0)
		{
			StickNode nodePositive(pointContainer, type, index, 1), nodeNegative(pointContainer, type, index, -1);//create two nodes with different direction, 1, stick point order is same as sequence, -1, vice verse
			container.push_back(nodePositive);
			container.push_back(nodeNegative);
			index++;
		}

		if(finish)//do not read the line after "---------"
			break;
	}

	//check each point number in each stick to make sure sticks are legal
	for(int i = 0; i < container.size(); i++)
	{
		vector<Coordinate> pointContainerTemp;
		pointContainerTemp = container[i].getContainer();

		if(pointContainerTemp.size() < 2)
		{
			cout<<"Pleas check file "<<name<<" to make sure the point number in each stick are legal ..."<<endl;
		}
	}
}

void showSequence(const vector<SequenceNode> &container)
{
	cout<<"\n=========Sequence==========="<<endl;
	for(int i = 0; i < container.size(); i++)
		container[i].show();
	cout<<"==============================\n"<<endl;
}

void readSequence(vector<SequenceNode> &container, string name)
{
		ifstream file;
		file.open(name.c_str());

		if(!file)
		{
			cerr<<"Can not open sequence file!"<<endl;
			exit(1);
		}

		//read sequence information
		string str;

		while(getline(file, str))
		{
			if(str.size() < 6 && str.size() > 1)//read type and index, such as "H0", "S1"
			{
				string type;
				type = str.substr(0, 1);
				int index;
				index = atoi(str.substr(1, str.size()-1).c_str());

				//read start index and end index for each SSEs
				vector<pair<int, int> > c;
				while(getline(file, str))
				{
					if(str.size() < 2)//break if read empty line, ready to read next record
						break;
					pair<int, int> p;

					int start, delimitor, end;
					start = str.find("(");
					delimitor = str.find(",");
					end = str.find(")");

					p.first = atoi(str.substr(start+1, delimitor-1-start).c_str());
					p.second = atoi(str.substr(delimitor+1, end-1-delimitor).c_str());
					c.push_back(p);
				}

				SequenceNode node(c, type, index);//create new sequence node

				container.push_back(node);//push sequence node to sequence node container
			}
		}

		//close sequence input file
		file.close();
}

#endif
